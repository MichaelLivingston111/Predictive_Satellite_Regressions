---
title: "Satellite_predictive_model"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Upload required libraries:
```{r}

suppressMessages(library(ggplot2))
suppressMessages(library(caret))
suppressMessages(library(ggpubr))
suppressMessages(library(MuMIn))
suppressMessages(library(lme4))

```

# Linear mixed models are an extension of simple linear models to allow both fixed and random effects, and are particularly used when there is non independence in the data, such as arises from a hierarchical structure. For example, students could be sampled from within classrooms, or patients from within doctors, or (as in th is case), samples can be taken within distinct seasons.



# Upload all the data, and sort into workable dataframes:
```{r}

# Upload the data from a total data file:
total_data <- read.csv("Total_data.csv")
total_data$Log_Chl <- log(total_data$Chl) # log transform the chlorophyll data

# Extract the data that we want to work with - only data from the upper mixed layer:
total_ML_split <- split(total_data, total_data$UpperMixed)  # Split the data set

# Create a data frame with just upper mixed layer samples >30m:
UpperMixed_data <- total_ML_split$Y  

Spring_data <- split(UpperMixed_data, UpperMixed_data$Season)  # Split data set by season

Spring_data <- Spring_data$Spring  # All spring data from the upper mixed layer

```

# CREATE THE REGRESSION ALGORITHM: Linear mixed effects model
```{r}

model1 <- lmer(TEP ~ Log_Chl + Temperature + (1|Season), data = UpperMixed_data)
# model1 <- lmer(TEP ~ Log_Chl + SST + (1|Season), data = UpperMixed_data)
# model1 <- lm(TEP ~ Log_Chl + (Temperature * Season), data = UpperMixed_data)

summary(model1)  # Get a model summary

# The random effects section tells us how much variance we find among levels of our grouping factors, plus residual variance.
# Here we find that the differences between seasons explains ~30% of the total variation, or the left over variation after the variance explained by the fixed effects.

# Obtain R2 values:
r.squaredGLMM(model1)

# Marginal R_GLMM² represents the variance explained by the fixed effects
# Conditional R_GLMM² is interpreted as a variance explained by the entire model, including both fixed and random effects

```

# Checking model assumptions: Equal variance and normal distribution of model residuals:
```{r}

# Get the linear model residuals:
UpperMixed_data$resid1 <- resid(model1)  

# Residual plot:
plot(model1)  # Residuals

# Plot the distribution of the linear model residuals:
H_model1 <- ggplot(data = UpperMixed_data, aes(resid1)) + 
  geom_histogram(binwidth = 5, colour = "white", fill = "dodgerblue") 
H_model1

# Plot a qqplot to visualize normality:
qqnorm(resid(model1))
qqline(resid(model1))

# Use the Shapiro-Wilks test to test for normality distributions in the lm residuals:
shapiro.test(UpperMixed_data$resid1) 

```

# TRAINING AND TESTING SETS - SPLITTING THE DATA
```{r}
# Perform cross validations to test the model. Split the data set into a training set (70%) and a testing set (30%):

# Set seed to replicate the same data partitions each time the code chunk is run:
set.seed(1972) # 124, 1972

# Create the data split 70:30 training:testing:
training.samples <- createDataPartition(UpperMixed_data$TEP, p = 0.75, list = FALSE)
train.data1  <- UpperMixed_data[training.samples, ]  # Training set
test.data1 <- UpperMixed_data[-training.samples, ]  # Testing set


```

# CROSS VALIDATION AND MODEL COMPARISON: linear models
```{r}

# Validation model:
val_model1 <- lmer(TEP ~ Log_Chl + Temperature + (1|Season) + (1|Region), data = train.data1)


# Get predictions for the validation model training and testing sets:
test.data1$predict1 <- predict(model1, test.data1, type = "response")
train.data1$predict1 <- predict(model1, train.data1, type = "response")


# Plot the results as 'True' values vs 'Predicted' values for the model:
ggplot() + 
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") +  # Add a 1:1 line
    geom_point(aes(x = test.data1$TEP, y = test.data1$predict1), 
                   color = "red", fill = "red") +
    geom_point(aes(x = train.data1$TEP, y = train.data1$predict1),
                   color = "black", fill = "black", pch = 1) +
    ylim(0, 175) +
    xlim(0, 175) +
    ylab("Predicted TEP Concentrations") +
    xlab("Measured TEP Concentrations") +
    theme_pubr()

```

# Determine the accuracy of the model:
```{r}

# Obtain the Root Mean Square Error and Mean Absolute Error for the linear 
# models - this will give us an estimate of their accuracy.

mean_total <- mean(UpperMixed_data$TEP)  # Calculate mean of true values

mean_total <- mean(UpperMixed_data$TEP)  # Calculate mean of true values

#Model1
model1RMSE <- RMSE(test.data1$predict1, test.data1$TEP)
model1MAE <- MAE(test.data1$predict1, test.data1$TEP)

print(paste("The RMSE of model1 predictions is", model1RMSE))
print(paste("The MAE of model1 predictions is", model1MAE))
print(paste("The RMSE % of the mean for model1 is", 
            (model1RMSE/mean_total) * 100))


```

Now, perform 5X model cross validation:
```{r}

# Create the data split 70:30 training:testing:
set.seed(55)
training.samples2 <- createDataPartition(UpperMixed_data$TEP, p = 0.75, list = FALSE)
train.data2  <- UpperMixed_data[training.samples2, ]  # Training set
test.data2 <- UpperMixed_data[-training.samples2, ]  # Testing set

set.seed(11)
training.samples3 <- createDataPartition(UpperMixed_data$TEP, p = 0.75, list = FALSE)
train.data3  <- UpperMixed_data[training.samples3, ]  # Training set
test.data3 <- UpperMixed_data[-training.samples3, ]  # Testing set

set.seed(22)
training.samples4 <- createDataPartition(UpperMixed_data$TEP, p = 0.75, list = FALSE)
train.data4  <- UpperMixed_data[training.samples4, ]  # Training set
test.data4 <- UpperMixed_data[-training.samples4, ]  # Testing set

set.seed(747)
training.samples5 <- createDataPartition(UpperMixed_data$TEP, p = 0.75, list = FALSE)
train.data5  <- UpperMixed_data[training.samples5, ]  # Training set
test.data5 <- UpperMixed_data[-training.samples5, ]  # Testing set

# Validation models:
val_model2 <- lmer(TEP ~ Log_Chl + Temperature + (1|Season) + (1|Region), data = train.data2)
val_model3 <- lmer(TEP ~ Log_Chl + Temperature + (1|Season) + (1|Region), data = train.data3)
val_model4 <- lmer(TEP ~ Log_Chl + Temperature + (1|Season) + (1|Region), data = train.data4)
val_model5 <- lmer(TEP ~ Log_Chl + Temperature + (1|Season) + (1|Region), data = train.data5)


# Get predictions for the validation model training and testing sets:
test.data2$predict2 <- predict(model2, test.data2, type = "response")
test.data3$predict3 <- predict(model2, test.data3, type = "response")
test.data4$predict4 <- predict(model2, test.data4, type = "response")
test.data5$predict5 <- predict(model2, test.data5, type = "response")


# Plot the results of the 5X cross validation:
ggplot() + 
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") +  # Add a 1:1 line
    geom_point(aes(x = test.data1$TEP, y = test.data1$predict1), 
                   ) +
    geom_point(aes(x = test.data2$TEP, y = test.data2$predict2), 
                   ) +
    geom_point(aes(x = test.data3$TEP, y = test.data3$predict3), 
                   ) +
    geom_point(aes(x = test.data4$TEP, y = test.data4$predict4), 
                   ) +
    geom_point(aes(x = test.data5$TEP, y = test.data5$predict5), 
                   ) +
    ylim(0, 175) +
    xlim(0, 175) +
    ylab("Predicted TEP Concentrations") +
    xlab("Measured TEP Concentrations") +
    theme_pubr()


# Accuracy calculation:
model1RMSE <- RMSE(test.data1$predict1, test.data1$TEP)
model1MAE <- MAE(test.data1$predict1, test.data1$TEP)

model2RMSE <- RMSE(test.data2$predict2, test.data2$TEP)
model2MAE <- MAE(test.data2$predict2, test.data2$TEP)

model3RMSE <- RMSE(test.data3$predict3, test.data3$TEP)
model3MAE <- MAE(test.data3$predict3, test.data3$TEP)

model4RMSE <- RMSE(test.data4$predict4, test.data4$TEP)
model4MAE <- MAE(test.data4$predict4, test.data4$TEP)

model5RMSE <- RMSE(test.data5$predict5, test.data5$TEP)
model5MAE <- MAE(test.data5$predict5, test.data5$TEP)


RMSE_Avg <- mean(model1RMSE, model2RMSE, model3RMSE, model4RMSE, model5RMSE)
print(RMSE_Avg)

```


# Visaulize the fixed effects for each predictor variable in each factor:
```{r}

# Temperature:
Temp <- ggplot(UpperMixed_data, aes(x = Temperature, y = TEP, colour = Season)) +
  facet_wrap(~Season, nrow = 3) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(method = 'lm') +
  theme_classic() +
  theme(
  strip.background = element_blank(),
  strip.text.x = element_blank())

# Chlorophyll:
Chl <- ggplot(UpperMixed_data, aes(x = Log_Chl, y = TEP, colour = Season)) +
  facet_wrap(~Season, nrow = 3) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(method = 'lm') + 
  ylab("") +
  theme_classic() +
  theme(
  strip.background = element_blank(),
  strip.text.x = element_blank())

# SST:
SST <- ggplot(UpperMixed_data, aes(x = SST, y = TEP, colour = Season)) +
  facet_wrap(~Season, nrow = 3) + 
  geom_point(alpha = 0.5) + 
  geom_smooth(method = 'lm') + 
  theme_classic() +
  theme(
  strip.background = element_blank(),
  strip.text.x = element_blank())

SST
Temp


# Arrange the figures into one:
ggarrange(Temp, Chl, nrow = 1, common.legend = TRUE)

```




