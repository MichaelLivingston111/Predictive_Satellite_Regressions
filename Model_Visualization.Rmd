---
title: "Model_Comparisons"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```




# In the previous files on this repoository, I created three sets of models to estimate exopolymer concentrations from different combinations of vairables based on the availability of the data and the practical considerations for each model. These included:

  A) An 'optimal feature' model, which aims to create the best possible model on all features reported. This type of model is limited in use, beacuse it relies on a large number of features to be reported. As such, it is only relevant in theory, or in large databases that may report all the features.
  
  B) A 'Satellite sensor' model. This model can be veru useful as it was built specifically using features reported by satellites, including temperature, chlorophyll, POC and time of year. While not quite as accurate as the optimal feature model, it is still quite accurate.
  
  C) A 'remote sensor' model, which is designed using features reported from mobile remote sensors, such as on CTDs. 
  




# Upload required libraries:
```{r}

suppressMessages(library(ggplot2))
suppressMessages(library(caret))
suppressMessages(library(ggpubr))
suppressMessages(library(MuMIn))
suppressMessages(library(lme4))
suppressMessages(library(feather))
suppressMessages(library(arrow))
suppressMessages(library(dplyr))
suppressMessages(library(viridis))
suppressMessages(library(grid))
suppressMessages(library(car))
suppressMessages(library(jtools))
suppressMessages(library(cowplot))
suppressMessages(library(reshape2))

```


# Upload all the data, and sort into workable dataframes:
```{r}

# Upload the data from a total data file:
total_data <- read.csv("Total_Sat_Data_All_Var.csv")
total_data2 <- read.csv("Remote_Sensor_model.csv")

# Specify all the relevant variables (requires 2 different data sets):
remote_data <- total_data2 %>% select(TEP, Temperature, DO, Log_MLD, Season, Log_Fluor, Sigma)

```


# Create all the models of interest. All model assumptions have already been checked, and their accuracies determined with cross validation techniques. More detail on these models in their respective files:
```{r}

# Optimal feature model:
feature_lmer <-  lmer(TEP ~ Log_Chl + Temperature + DO + Log_MLD + Avg_PAR + Sigma + (1|Season), data = total_data)
r.squaredGLMM(feature_lmer)

# Satellite sensor models:
satellite_lm <- lm(TEP ~ Log_Chl + POC + Temperature + Season, data = total_data)
r.squaredGLMM(satellite_lm)

# Remote sensor models:
remote_lm <-  lm(TEP ~ Temperature + DO + Log_MLD + Log_Fluor + Sigma, data = total_data2)
r.squaredGLMM(remote_lm)

```


# Calculate residuals for each model, make plots of residual distributions and residuals vs fitted:
```{r}

# Optimal feature model:
total_data$feature_resid <-  resid(feature_lmer)
total_data$feature_fit <-  predict(feature_lmer)

# Satellite sensor models:
total_data$satellite_resid <-  resid(satellite_lm)
total_data$satellite_fit <-  predict(satellite_lm)

# Remote sensor models:
total_data2$remote_resid <-  resid(remote_lm)
total_data2$remote_fit <-  predict(remote_lm)


# Residual distribution plot (histogram):
feature_hist <- ggplot(data = total_data, aes(feature_resid)) + 
  geom_histogram(binwidth = 2, colour = "black", fill = "white") +
  xlab("Residuals") +
  ylab("Count") +
  theme_pubr()

satellite_hist <- ggplot(data = total_data, aes(satellite_resid)) + 
  geom_histogram(binwidth = 2, colour = "black", fill = "white") +
  xlab("Residuals") +
  ylab("Count") +
  theme_pubr()

remote_hist <- ggplot(data = total_data2, aes(remote_resid)) + 
  geom_histogram(binwidth = 2, colour = "black", fill = "white") +
  xlab("Residuals") +
  ylab("Count") +
  theme_pubr()

Histogram <- ggarrange(feature_hist, satellite_hist, remote_hist, ncol = 3)


# Residual auto-correlation plots:
feature_AC <- ggplot(data = total_data, aes(feature_fit, feature_resid)) + 
  geom_point(colour = "black", fill = "white") +
  xlab("Fitted") +
  geom_smooth(method = 'lm') +
  ylab("Residuals") +
  ylim(-40, 40) +
  theme_pubr()

satellite_AC <- ggplot(data = total_data, aes(satellite_fit, satellite_resid)) + 
  geom_point(colour = "black", fill = "white") +
  xlab("Fitted") +
  geom_smooth(method = 'lm') +
  ylab("Residuals") +
  ylim(-40, 40) +
  theme_pubr()

remote_AC <- ggplot(data = total_data2, aes(remote_fit, remote_resid)) + 
  geom_point(colour = "black", fill = "white") +
  geom_smooth(method = 'lm') +
  xlab("Fitted") +
  ylab("Residuals") +
  ylim(-40, 40) +
  theme_pubr()

Autocorrelation <- ggarrange(feature_AC, satellite_AC, remote_AC, ncol = 3)


# Combine plots:

Figure <- ggarrange(Histogram, Autocorrelation, ncol = 1)
Figure

```

# Check model assumptions:
```{r}

# Multicollinearity?
car::vif(feature_lmer)
car::vif(satellite_lm)
car::vif(remote_lm)


# Normality in residual distribution?
shapiro.test(resid(feature_lmer)) 
shapiro.test(resid(satellite_lm))
shapiro.test(resid(remote_lm)) 

```




# Perfrom a 25x cross validation to assess the accuracy of these models on new data. 
```{r}

# Containers for the predictions and accuracy measurements:

sample_train <- NULL
sample_train2 <- NULL

# Forward selections:
feature_lmer_predict <- NULL
feature_lmer_RMSE <- NULL
feature_lmer_MAE <- NULL

satellite_lm_predict <- NULL
satellite_lm_RMSE <- NULL
satellite_lm_MAE <- NULL

remote_lm_predict <- NULL
remote_lm_RMSE <- NULL
remote_lm_MAE <- NULL


# Loop through model prediction and perform 25x cross validation. 
# The model is trained on 95% of the data, and validated on the other 5%

for (i in 1:30) {
  
  #Creating a re-sampled data set from the total data:
  training.samples <- createDataPartition(total_data$TEP, p = 0.95, list = FALSE)
  train.data1  <- total_data[training.samples, ]  # Training set
  test.data1 <- total_data[-training.samples, ]  # Testing set
  
  #Creating a re-sampled data set from the total data(2):
  training.samples <- createDataPartition(total_data2$TEP, p = 0.95, list = FALSE)
  train.data2  <- total_data2[training.samples, ]  # Training set
  test.data2 <- total_data2[-training.samples, ]  # Testing set
  
  
  # Running the models and creating predictions, accuracy metrics on the partitioned training data:
  
  # Feature:
  feature_lmer_CV<- lmer(TEP ~ Log_Chl + Temperature + DO + Log_MLD + Avg_PAR + Sigma + (1|Season), data = train.data1) 

  
  # Satellite:
  satellite_lm_CV<- lm(TEP ~ Temperature + Log_Chl + POC + Season, data = train.data1) 
  
  # Remote:
  remote_lm_CV <-  lm(TEP ~ Temperature + DO + Log_MLD + Log_Fluor + Sigma + Season, data = train.data2)
  
  
  # Model 'true' training points, applies to each model:
  sample_train <- c(sample_train, test.data1$TEP)
  sample_train2 <- c(sample_train2, test.data2$TEP)
  
  
  
  # Model predictions and error calculations:
  
  # Feature:
  feature_lmer_predict <- c(feature_lmer_predict, predict(feature_lmer_CV, test.data1, 
                                                type = "response", allow.new.levels = TRUE))  # Predictions
  
  feature_lmer_RMSE <- c(feature_lmer_RMSE, RMSE(feature_lmer_predict, sample_train))  # RMSE
  
  feature_lmer_MAE <- c(feature_lmer_MAE, MAE(feature_lmer_predict, sample_train))  # RMSE
  

  # Satellite:
  satellite_lm_predict <- c(satellite_lm_predict, predict(satellite_lm_CV, test.data1, 
                                                type = "response", allow.new.levels = TRUE))  # Predictions
  
  satellite_lm_RMSE <- c(satellite_lm_RMSE, RMSE(satellite_lm_predict, sample_train))  # RMSE
  
  satellite_lm_MAE <- c(satellite_lm_MAE, MAE(satellite_lm_predict, sample_train))  # RMSE
  
  
  # Remote:
  remote_lm_predict <- c(remote_lm_predict, predict(remote_lm_CV, test.data2, 
                                                type = "response", allow.new.levels = TRUE))  # Predictions
  
  remote_lm_RMSE <- c(remote_lm_RMSE, RMSE(remote_lm_predict, sample_train2))  # RMSE
  
  remote_lm_MAE <- c(remote_lm_MAE, MAE(remote_lm_predict, sample_train2))  # RMSE
  
  
}


# The above loop generated 25 different regression models with model coefficients, y intercepts and predictions, specified below for each of the models created: 

predictions <- cbind(feature_lmer_predict, satellite_lm_predict, remote_lm_predict, sample_train, sample_train2)
predictions <- as.data.frame(predictions)  # as a data frame

```


# Plot the results of the cross validation:
```{r}

CV_plot <- ggplot(predictions, aes()) +
  
  # Feature:
    #geom_point(aes(x = sample_train, y = feature_lmer_predict), 
               #alpha = 1, colour = "black") +  
  
  # Satellite:
    geom_point(aes(x = sample_train, y = satellite_lm_predict), 
               alpha = 1, colour = "slateblue") +
    geom_smooth(aes(x = sample_train, y = satellite_lm_predict), method = 'lm') +
  
  # Remote:
    #geom_point(aes(x = sample_train2, y = remote_lm_predict), 
               #alpha = 1, colour = "darkgray") +
  
    geom_abline(slope = 1, intercept = 0, linetype = "dashed") +
    ggtitle("") +
    ylim(0, 175) +
    xlim(0, 175) +
    ylab("Predicted TEP") +
    xlab("Measured TEP") +
    theme_pubr() +
    labs(title = "Satellite model", tag = "A")
    theme(plot.title=element_text(size=8,face="bold"))

CV_plot


```

# Compare all the model accuracies with mean absolutew errors:
```{r}




# Get the MAE:
MAE_df <- cbind(feature_lmer_MAE, satellite_lm_MAE, remote_lm_MAE)
MAE_df <- as.data.frame(MAE_df)
colnames(MAE_df) <- c("Feature", "Satellite", "Remote")


MAE_dff <- melt(MAE_df,  variable.name = 'MAE')

MAE <- colMeans(MAE_df)
print(MAE)


MAE_box <- ggplot(MAE_dff, aes(x = MAE, y = value)) +
  geom_boxplot(fill = "slateblue", alpha = 0.3) +
  ylab("Mean absolute error") +
  xlab("") +
  ylim(6, 17) +
  labs(tag = "B") +
  theme_pubr()

MAE_box

```

# Print out accuracy figures:
```{r}

# Specify all coordiantes:
pdf(file = "/Users/michaellivingston/Desktop/Optimal_accuracy_metrics.pdf",   # The directory you want to save the file in
    width = 11, # The width of the plot in inches
    height = 7) # The height of the plot in inches

ggarrange(CV_plot, MAE_box)

dev.off()


```



# Compare the relaitve strengths of each feature/coefficient from each model:
```{r}

plot_coefs(feature_lmer, satellite_lm, remote_lm, scale = TRUE,
           model.names = c("Feature", "Satellite", "Remote"))

```





  